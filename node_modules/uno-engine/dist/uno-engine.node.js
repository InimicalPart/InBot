module.exports=function(e){var t={};function r(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(s,i,function(t){return e[t]}.bind(null,i));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=3)}([function(e,t){e.exports=require("@babel/runtime/helpers/defineProperty")},function(e,t){e.exports=require("shuffle")},function(e,t){e.exports=require("events")},function(e,t,r){"use strict";r.r(t),r.d(t,"Card",(function(){return l})),r.d(t,"Colors",(function(){return n})),r.d(t,"Values",(function(){return a})),r.d(t,"BeforeDrawEvent",(function(){return c})),r.d(t,"DrawEvent",(function(){return d})),r.d(t,"BeforePassEvent",(function(){return u})),r.d(t,"BeforeCardPlayEvent",(function(){return f})),r.d(t,"CardPlayEvent",(function(){return p})),r.d(t,"NextPlayerEvent",(function(){return y})),r.d(t,"GameEndEvent",(function(){return E})),r.d(t,"Game",(function(){return O}));var s=r(0),i=r.n(s);let n,a;!function(e){e[e.RED=1]="RED",e[e.BLUE=2]="BLUE",e[e.GREEN=3]="GREEN",e[e.YELLOW=4]="YELLOW"}(n||(n={})),function(e){e[e.ZERO=0]="ZERO",e[e.ONE=1]="ONE",e[e.TWO=2]="TWO",e[e.THREE=3]="THREE",e[e.FOUR=4]="FOUR",e[e.FIVE=5]="FIVE",e[e.SIX=6]="SIX",e[e.SEVEN=7]="SEVEN",e[e.EIGHT=8]="EIGHT",e[e.NINE=9]="NINE",e[e.DRAW_TWO=10]="DRAW_TWO",e[e.REVERSE=11]="REVERSE",e[e.SKIP=12]="SKIP",e[e.WILD=13]="WILD",e[e.WILD_DRAW_FOUR=14]="WILD_DRAW_FOUR"}(a||(a={}));class l{constructor(e,t){if(i()(this,"_value",void 0),i()(this,"_color",void 0),this._value=e,this._color=void 0===t?void 0:t,!this.isWildCard()&&void 0===this.color)throw Error("Only wild cards can be initialized with no color")}get color(){return this._color}set color(e){if(!this.isWildCard())throw new Error("Only wild cards can have theirs colors changed.");if(void 0===e||e<1||e>4)throw new Error("The color must be a value from Colors enum.");this._color=e}get value(){return this._value}isWildCard(){return this.value===a.WILD||this.value===a.WILD_DRAW_FOUR}isSpecialCard(){return this.isWildCard()||this.value===a.DRAW_TWO||this.value===a.REVERSE||this.value===a.SKIP}matches(e){if(this.isWildCard())return!0;if(void 0===this.color||void 0===e.color)throw new Error("Both cards must have theirs colors set before comparing");return e.value===this.value||e.color===this.color}get score(){switch(this.value){case a.DRAW_TWO:case a.SKIP:case a.REVERSE:return 20;case a.WILD:case a.WILD_DRAW_FOUR:return 50;default:return this.value}}is(e,t){let r=this.value===e;return t&&(r=r&&this.color===t),r}toString(){return"".concat(n[this.color]||"NO_COLOR"," ").concat(a[this.value])}}const o={isCancelable:!0};class h{get type(){return this._type}get isCancelable(){return this._isCancelable}get canceled(){return this._canceled}constructor(e,t){if(i()(this,"_type",void 0),i()(this,"_isCancelable",void 0),i()(this,"_canceled",void 0),!e)throw new Error("Event type is mandatory");void 0===(t=Object.assign({},o,t)).isCancelable&&(t.isCancelable=!0),this._type=e,this._isCancelable=t.isCancelable,this._canceled=!1}preventDefault(){this.isCancelable&&(this._canceled=!0)}}class c extends h{constructor(e,t){super("beforedraw"),this.player=e,this.quantity=t}}class d extends h{constructor(e,t){super("draw"),this.player=e,this.cards=t}}class u extends h{constructor(e){super("beforepass"),this.player=e}}class f extends h{constructor(e,t){super("beforecardplay"),this.card=e,this.player=t}}class p extends h{constructor(e,t){super("cardplay"),this.card=e,this.player=t}}class y extends h{constructor(e){super("nextplayer"),this.player=e}}class E extends h{constructor(e,t){super("end",{isCancelable:!1}),this.winner=e,this.score=t}}var v=r(1);function _(){const e=[],t=(e,t,r)=>{const s=[];for(let i=0;i<e;i++)s.push(new l(t,r));return s};for(let r=1;r<=4;r++){e.push.apply(e,t(1,a.ZERO,r));for(let s=a.ONE;s<=a.NINE;s++)e.push.apply(e,t(2,s,r));e.push.apply(e,t(2,a.DRAW_TWO,r)),e.push.apply(e,t(2,a.SKIP,r)),e.push.apply(e,t(2,a.REVERSE,r))}return e.push.apply(e,t(4,a.WILD)),e.push.apply(e,t(4,a.WILD_DRAW_FOUR)),e}class w{get cards(){return this.shuffle.cards}get length(){return this.shuffle.length}constructor(){i()(this,"originalDraw",void 0),i()(this,"shuffle",Object(v.shuffle)({deck:_()}))}draw(e){let t=[];if((e=e||1)>=this.length){const r=this.length;if(t=t.concat(this.shuffle.draw.call(this,r)),this.shuffle.reset(),this.shuffle.shuffle(),0===(e-=r))return t}return t.concat(this.shuffle.draw(e))}}var g=r(2);class C extends g.EventEmitter{on(e,t){return super.on(e,(r=t,s=this,function(e){return!1!==r.call(s,e)||e.preventDefault(),!e.canceled}));var r,s}emit(e,t){throw new Error("Event dispatching must be done via #dispatchEvent")}dispatchEvent(e){return this.listeners(e.type).every(t=>t(e))}}let P;!function(e){e[e.CLOCKWISE=1]="CLOCKWISE",e[e.COUNTER_CLOCKWISE=2]="COUNTER_CLOCKWISE"}(P||(P={}));class m{constructor(e){if(i()(this,"name",void 0),i()(this,"hand",[]),!(e=e?e.trim():e))throw new Error("Player must have a name");this.name=e}getCardByValue(e){if(e)return this.hand.find(t=>t.value===e)}hasCard(e){return!!e&&this.hand.some(t=>t.value===e.value&&t.color===e.color)}removeCard(e){if(!this.hasCard(e))return;const t=this.hand.findIndex(t=>t.value===e.value&&t.color===e.color);this.hand.splice(t,1)}valueOf(){return this.name}toString(){return this.name}}class O extends C{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];super(),i()(this,"drawPile",void 0),i()(this,"direction",void 0),i()(this,"_currentPlayer",void 0),i()(this,"_players",[]),i()(this,"_discardedCard",void 0),i()(this,"drawn",!1),i()(this,"yellers",{}),this._players=this.fixPlayers(e),t.forEach(e=>e.setup(this)),this.newGame()}newGame(){this.drawPile=new w,this.direction=P.CLOCKWISE,this._players.forEach(e=>e.hand=this.drawPile.draw(7));do{this._discardedCard=this.drawPile.draw()[0]}while(this._discardedCard.isSpecialCard());var e,t;this._currentPlayer=this._players[(e=0,t=this._players.length-1,Math.floor(Math.random()*(t-e+1))+e)]}getPlayer(e){const t=this._players[this.getPlayerIndex(e)];if(t)return t}get currentPlayer(){return this._currentPlayer}set currentPlayer(e){if(!(e=this.getPlayer(e.name)))throw new Error("The given player does not exist");this._currentPlayer=e}get nextPlayer(){return this.getNextPlayer()}get discardedCard(){return this._discardedCard}set discardedCard(e){if(e){if(void 0===e.color||null===e.color)throw new Error("Discarded cards cannot have theirs colors as null");this._discardedCard=e}}get players(){return this._players}get deck(){return this.drawPile}get playingDirection(){return this.direction}set playingDirection(e){if(e!==P.CLOCKWISE&&e!=P.COUNTER_CLOCKWISE)throw new Error("Invalid direction");e!==this.direction&&this.reverseGame()}draw(e,t){let{silent:r}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{silent:!1};if(0==arguments.length&&(e=this._currentPlayer),t=t||1,!r&&!this.dispatchEvent(new c(e,t)))return;const s=this.privateDraw(e,t);(r||this.dispatchEvent(new d(e,s)))&&(this.drawn=!0,this.yellers[e.name]=!1)}pass(){if(!this.drawn)throw new Error("".concat(this._currentPlayer," must draw at least one card before passing"));this.dispatchEvent(new u(this._currentPlayer))&&this.goToNextPlayer()}play(e){let{silent:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{silent:!1};const r=this._currentPlayer;if(e){if(!r.hasCard(e))throw new Error("".concat(r," does not have card ").concat(e," at hand"));if(t||this.dispatchEvent(new f(e,this._currentPlayer))){if(null==e.color)throw new Error("Card must have its color set before playing");if(!e.matches(this._discardedCard))throw new Error("".concat(this._discardedCard,", from discard pile, does not match ").concat(e));if(r.removeCard(e),this._discardedCard=e,t||this.dispatchEvent(new p(e,this._currentPlayer)))if(0!=r.hand.length){switch(this._discardedCard.value){case a.WILD_DRAW_FOUR:this.privateDraw(this.getNextPlayer(),4),this.goToNextPlayer(!0);break;case a.DRAW_TWO:this.privateDraw(this.getNextPlayer(),2),this.goToNextPlayer(!0);break;case a.SKIP:this.goToNextPlayer(!0);break;case a.REVERSE:this.reverseGame(),2==this._players.length&&this.goToNextPlayer(!0)}this.goToNextPlayer()}else{const e=this.calculateScore();this.dispatchEvent(new E(this._currentPlayer,e))}}}}uno(e){let t;return(e=e||this._currentPlayer).hand.length<=2&&!this.yellers[e.name]?(this.yellers[e.name]=!0,[]):(t=this._players.filter(e=>1==e.hand.length&&!this.yellers[e.name]),0==t.length&&(t=[e]),t.forEach(e=>this.privateDraw(e,2)),t)}fixPlayers(e){if(!e||!e.length||e.length<2||e.length>10)throw new Error("There must be 2 to 10 players in the game");if(function(e){const t=e.map((e,t)=>({count:1,name:e})).reduce((e,t)=>(e[t.name]=(e[t.name]||0)+t.count,e),{});return Object.keys(t).filter(e=>t[e]>1)}(e).length)throw new Error("Player names must be different");return e.map(e=>new m(e))}getNextPlayer(){let e=this.getPlayerIndex(this._currentPlayer);return++e==this._players.length&&(e=0),this._players[e]}getPlayerIndex(e){return"string"!=typeof e&&(e=e.name),this._players.map(e=>e.name).indexOf(e)}goToNextPlayer(e){this.drawn=!1,this._currentPlayer=this.getNextPlayer(),e||this.dispatchEvent(new y(this._currentPlayer))}reverseGame(){this._players.reverse(),this.direction=this.direction==P.CLOCKWISE?P.COUNTER_CLOCKWISE:P.CLOCKWISE}privateDraw(e,t){if(!e)throw new Error("Player is mandatory");const r=this.drawPile.draw(t);return e.hand=e.hand.concat(r),r}calculateScore(){return this._players.map(e=>e.hand).reduce((e,t)=>e+=t.reduce((e,t)=>e+t.score,0),0)}}}]);
//# sourceMappingURL=uno-engine.node.js.map